//  The main export of this module creates and returns a `parse` function,
//  given a set of syntax options.
//  
//  The `parse` function takes an expression string as input and returns an
//  `evaluate` function.
//
//  The `evaluate` function takes an evaluation context as input and returns
//  the expression value as output.

const Lexer = require("./lexer");



class Parser {
    
    constructor (options) {
        this.options = options;
        
        // create the lexer, given the list of the valid operators
        this.lexer = new Lexer({
            binaryOperators: Object.keys(options.binaryOperations),
            unaryOperators: Object.keys(options.unaryOperations)
        });
    }
    
    tokenize (source) {
        return new Tokens(...this.lexer.tokenize(source));
    }
    
    // The `createOperation` funcction returns a function that, once called
    // with a `context` object, executes an operation and return its value.
    // Each operation is a node of the AST generated by this parser: each
    // operand of the operation is in turn either another operation or
    // a value (leaf).
    createOperation (handlerName, operands, position) {
        return async context => {
            try {
                if (typeof context[handlerName] !== "function") {
                    throw new Error(`'${handlerName}' handler not defined in this context`);
                }                
                return await context[handlerName](...operands, position);
                
            } catch (error) {
                return await context[this.options.errorHandler](error, position);
            }
        }
    }
    
    createSyntaxError (message, token) {
        return new Lexer.SyntaxError(message, token.position.source, token.position.index);
    }
    
    // The following tuns turns the next tokens into a single Operation tree.
    // It stops when the passed `done` condition is true
    parseExpression (tokens, done) {
        
        // If the `done` condition is immediately true, than the expression
        // is empty and the `void` operation is returned.
        if (done()) {
            const lastToken = tokens.get() || tokens.last || tokens.tail;
            tokens.inc(); return this.createOperation(this.options.voidHandler, [], lastToken.position);
        }
        
        // First generates an `expression` list [operand, operator, operand, operator, ...].
        // Then sorts the operators by precedence and returns a function.
        
        // Initialize the `epression` list with the first operand.
        var expression = [ this.parseOperand(tokens) ];
        
        // Iterate over all the other operators and operands and add them
        // to the `expression` list until the `done` condition is matched.
        while (!done()) {
            
            if (tokens.get() && tokens.get().matchBinaryOperator()) {
                let operator = Object.create(this.options.binaryOperations[tokens.get().value]);
                operator.position = tokens.get().position;
                tokens.inc(); 
                expression.push(operator);                
                if (done()) {
                    throw this.createSyntaxError('Operand expected', tokens.get() || tokens.tail);
                }
                let operand = this.parseOperand(tokens);
                expression.push(operand);
            }
            else {
                // if the next token is not an operator, then an empty operator
                // is assumed. This means that the expression consists of 
                // two operands next to each other, without any interposed
                // operator.
                let operator = Object.create(this.options.binaryOperations[""]);
                operator.position = tokens.get(-1).position;
                expression.push(operator);
                let operand = this.parseOperand(tokens);
                expression.push(operand);
            }
        }
        tokens.inc();
        
        // Build the operations tree from the plain list [operand, operator, operand, ...]
        while (expression.length > 1) {
            
            // find higher precedence operand
            let precedence = 0;
            let operatorIndex = 0;
            for (let j=1; j<expression.length; j+=2) {
                let operator = expression[j];
                if (operator.precedence > precedence) {
                    if (operator.right) {
                        let handler = operator.handler;
                        while (expression[j+2] && expression[j+2].handler === handler) j += 2;
                    }
                    precedence = operator.precedence;
                    operatorIndex = j;
                }
            }
            
            // evaluate the higher precedence operation
            let leftHandOperand = expression[operatorIndex - 1];
            let operator = expression[operatorIndex];
            let rightHandOperand = expression[operatorIndex + 1];
            let operation = this.createOperation(operator.handler, [leftHandOperand, rightHandOperand], operator.position);
            
            // replace the [...,left,operator,right,...] items with the operation node
            expression.splice(operatorIndex-1, 3, operation);
        }
        
        // Returns the root operation
        return expression[0];                
    }
    
    // Returns the next operand in line.
    // An operand can be a value (leaf) or an branch of the operation tree.
    parseOperand (tokens) {
        var unaryOperator, operand;
        
        // If the operand is preceded by a unary operator
        if (tokens.get() && tokens.get().matchUnaryOperator()) {
            unaryOperator = tokens.get(); 
            tokens.inc();
        }
        
        // If just a number literal
        if (tokens.get() && tokens.get().matchNumberLiteral()) {
            operand = this.createOperation(this.options.numberHandler, [tokens.get().value], tokens.get().position); tokens.inc();
        }
        
        // If a string literal
        else if (tokens.get() && tokens.get().matchStringLiteral()) {
            if (tokens.get().quoteSymbol === `'`) operand = this.createOperation(this.options.stringHandler1, [tokens.get().value], tokens.get().position);
            else if (tokens.get().quoteSymbol === `"`) operand = this.createOperation(this.options.stringHandler2, [tokens.get().value], tokens.get().position);
            else if (tokens.get().quoteSymbol === '`') operand = this.createOperation(this.options.stringHandler3, [tokens.get().value], tokens.get().position);
            tokens.inc();
        }
        
        // If an identifier
        else if (tokens.get() && tokens.get().matchIdentifier()) {
            operand = this.createOperation(this.options.nameHandler, [tokens.get().value], tokens.get().position); tokens.inc();            
        }
        
        // If a subexpression between `(` and `)`
        else if (tokens.get() && tokens.get().matchSymbol('(')) {
            tokens.inc(); operand = this.parseExpression(tokens,  () => tokens.get() && tokens.get().matchSymbol(")") );
        }
        
        // If a subexpression between `[` and `]`
        else if (tokens.get() && tokens.get().matchSymbol('[')) {
            const position = tokens.get().position; tokens.inc();
            let expression = this.parseExpression(tokens,  () => tokens.get() && tokens.get().matchSymbol("]") );
            operand = this.createOperation(this.options.squareGroupHandler, [expression], position);
        }
        
        // If a subexpression between `{` and `}`
        else if (tokens.get() && tokens.get().matchSymbol('{')) {
            const position = tokens.get().position; tokens.inc();
            let expression = this.parseExpression(tokens,  () => tokens.get() && tokens.get().matchSymbol("}") );
            operand = this.createOperation(this.options.curlyGroupHandler, [expression], position);
        }
        
        // No valid operand found
        else {
            throw this.createSyntaxError('Operand expected', tokens.get() || tokens.tail);
        }
        
        if (unaryOperator) {
            const handler = this.options.unaryOperations[unaryOperator.value];
            return this.createOperation(handler, [operand], unaryOperator.position);
        } else {
            return operand;
        }
    }    
    
    
    parse (source) {
        try {
            // Perform the lexical analysis
            var tokens = this.tokenize(source);    // array of tokens
            tokens.tail = {position: new Lexer.Position(source, source.length)};
            
            // Parse the entier expression and return the `evaluate` function
            return this.parseExpression(tokens, () => tokens.done() );
            
        } catch (error) {
            return async context => await context[this.options.errorHandler](error);
        }        
    }
    
    static get Position () {
        return Lexer.Position;
    }
}



class Tokens {
    
    constructor (...tokens) {
        this.tokens = tokens;
        this.index = 0;
    }
    
    inc (step=1) {
        this.index += step;
        return this;
    }
    
    get (step=0) {
        return this.tokens[this.index+step];
    }
    
    get last () {
        return this.tokens[this.tokens.length-1];
    }
    
    done () {
        return this.index >= this.tokens.length;
    }
}



module.exports = Parser;
