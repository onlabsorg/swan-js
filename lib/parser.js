//  The main export of this module creates and returns a `parse` function,
//  given a set of syntax options.
//  
//  The `parse` function takes an expression string as input and returns an
//  `evaluate` function.
//
//  The `evaluate` function takes an evaluation context as input and returns
//  the expression value as output.

const Lexer = require("./lexer");


//  Parser factory: syntax options -> parse function
const Parser = module.exports = (options) => {
    
    // create the lexer, given the list of the valid operators
    const tokenize = Lexer({binaryOperators: Object.keys(options.binaryOperations)});    

    // parse function: expression source -> evaluate function`
    return source => {
        
        const SyntaxError = (message, token) => token ? 
                new Lexer.SyntaxError(message, token.position.source, token.position.index) :
                new Lexer.SyntaxError(message, source, source.length);

        // The `createOperation` funcction returns a function that, once called
        // with a `context` object, executes an operation and return its value.
        // Each operation is a node of the AST generated by this parser: each
        // operand of the operation is in turn either another operation or
        // a value (leaf).
        const createOperation = (handlerName, operands, position) => async context => {
            try {
                if (typeof context[handlerName] !== "function") {
                    throw new Error(`'${handlerName}' handler not defined in this context`);
                }                
                return await context[handlerName](...operands, position);
                
            } catch (error) {
                return await context[options.errorHandler](error, position);
            }
        }


        // The following tuns turns the next tokens into a single Operation tree.
        // It stops when the passed `done` condition is true
        const parseExpression = (done) => {
            
            // If the `done` condition is immediately true, than the expression
            // is empty and the `void` operation is returned.
            if (done()) {
                const lastToken = tokens[i] || tokens[tokens.length-1] || {position:0};
                i++; return createOperation(options.voidHandler, [], lastToken.position);
            }
            
            // First generates an `expression` list [operand, operator, operand, operator, ...].
            // Then sorts the operators by precedence and returns a function.
            
            // Initialize the `epression` list with the first operand.
            var expression = [ parseOperand() ];
            
            // Iterate over all the other operators and operands and add them
            // to the `expression` list until the `done` condition is matched.
            while (true) {
                
                // stop the loop when done
                if (done()) {
                    i++; break;
                }
                
                // Parse the next (operator, operand) pair
                if (tokens[i] && tokens[i].matchBinaryOperator()) {
                    let operator = Object.create(options.binaryOperations[tokens[i].value]);
                    operator.position = tokens[i].position;
                    expression.push(operator); i++;
                    if (done()) {
                        throw SyntaxError('Operand expected', tokens[i]);
                    }
                    let operand = parseOperand();
                    expression.push(operand);
                }
                else {
                    // if the next token is not an operator, then an empty operator
                    // is assumed. This means that the expression consists of 
                    // two operands next to each other, without any interposed
                    // operator.
                    let operator = options.binaryOperations[""];
                    operator.position = tokens[i-1].position;
                    expression.push(operator);
                    let operand = parseOperand();
                    expression.push(operand);
                }
            }
            
            // Build the operations tree from the plain list [operand, operator, operand, ...]
            while (expression.length > 1) {
                
                // find higher precedence operand
                let precedence = 0;
                let operatorIndex = 0;
                for (let j=1; j<expression.length; j+=2) {
                    let operator = expression[j];
                    if (operator.precedence > precedence) {
                        if (operator.right) {
                            let handler = operator.handler;
                            while (expression[j+2] && expression[j+2].handler === handler) j += 2;
                        }
                        precedence = operator.precedence;
                        operatorIndex = j;
                    }
                }
                
                // evaluate the higher precedence operation
                let leftHandOperand = expression[operatorIndex - 1];
                let operator = expression[operatorIndex];
                let rightHandOperand = expression[operatorIndex + 1];
                let operation = createOperation(operator.handler, [leftHandOperand, rightHandOperand], operator.position);
                
                // replace the [...,left,operator,right,...] items with the operation node
                expression.splice(operatorIndex-1, 3, operation);
            }
            
            // Returns the root operation
            return expression[0];        
        }
        
        // Returns the next operand in line.
        // An operand can be a value (leaf) or an branch of the operation tree.
        const parseOperand = () => {
            var operand;
            
            // If a + or - followd by a number litaral
            if (tokens[i] && tokens[i].matchSign() && tokens[i+1].matchNumberLiteral()) {
                let factor = tokens[i].value === "-" ? -1 : 1;
                operand = createOperation(options.numberHandler, [tokens[i+1].value * factor], tokens[i+1].position); i+=2;
            }
            
            // If just a number literal
            else if (tokens[i] && tokens[i].matchNumberLiteral()) {
                operand = createOperation(options.numberHandler, [tokens[i].value], tokens[i].position); i++;
            }
            
            // If a string literal
            else if (tokens[i] && tokens[i].matchStringLiteral()) {
                if (tokens[i].quoteSymbol === `'`) operand = createOperation(options.stringHandler1, [tokens[i].value], tokens[i].position);
                else if (tokens[i].quoteSymbol === `"`) operand = createOperation(options.stringHandler2, [tokens[i].value], tokens[i].position);
                else if (tokens[i].quoteSymbol === '`') operand = createOperation(options.stringHandler3, [tokens[i].value], tokens[i].position);
                i++;
            }
            
            // If an identifier
            else if (tokens[i] && tokens[i].matchIdentifier()) {
                operand = createOperation(options.nameHandler, [tokens[i].value], tokens[i].position); i++;            
            }
            
            // If a subexpression between `(` and `)`
            else if (tokens[i] && tokens[i].matchSymbol('(')) {
                i++; operand = parseExpression( () => tokens[i] && tokens[i].matchSymbol(")") );
            }
            
            // If a subexpression between `[` and `]`
            else if (tokens[i] && tokens[i].matchSymbol('[')) {
                const position = tokens[i].position; i++;
                let expression = parseExpression( () => tokens[i] && tokens[i].matchSymbol("]") );
                operand = createOperation(options.squareGroupHandler, [expression], position);
            }
            
            // If a subexpression between `{` and `}`
            else if (tokens[i] && tokens[i].matchSymbol('{')) {
                const position = tokens[i].position; i++;
                let expression = parseExpression( () => tokens[i] && tokens[i].matchSymbol("}") );
                operand = createOperation(options.curlyGroupHandler, [expression], position);
            }
            
            // No valid operand found
            else {
                throw SyntaxError('Operand expected', tokens[i]);
            }
            
            return operand;
        }
        
        try {
            // Perform the lexical analysis
            var tokens = tokenize(source);      // array of tokens
            var i = 0;                          // index of the next token in line            
            
            // Parse the entier expression and return the `evaluate` function
            return parseExpression( () => i >= tokens.length );
            
        } catch (error) {
            return async context => await context[options.errorHandler](error);
        }
    }
}

Parser.Position = Lexer.Position;
