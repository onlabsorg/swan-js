//  The main export of this module creates and returns a `parse` function,
//  given a set of syntax options.
//  
//  The `parse` function takes an expression string as input and returns an
//  `evaluate` function.
//
//  The `evaluate` function takes an evaluation context as input and returns
//  the expression value as output.

const Lexer = require("./lexer");



class Parser {
    
    constructor (options) {
        this.options = options;
        
        // create the lexer, given the list of the valid operators
        this.lexer = new Lexer({
            binaryOperators: Object.keys(options.binaryOperations),
            unaryOperators: Object.keys(options.unaryOperations)
        });
    }
    
    tokenize (source) {
        return new Tokens(...this.lexer.tokenize(source));
    }
    
    // The `createOperation` funcction returns a function that, once called
    // with a `context` object, executes an operation and return its value.
    // Each operation is a node of the AST generated by this parser: each
    // operand of the operation is in turn either another operation or
    // a value (leaf).
    createOperation (handlerName, operands, position) {
        return async context => {
            try {
                if (typeof context[handlerName] !== "function") {
                    throw new Error(`'${handlerName}' handler not defined in this context`);
                }                
                return await context[handlerName](...operands, position);
                
            } catch (error) {
                return await context[this.options.errorHandler](error, position);
            }
        }
    }
    
    createSyntaxError (message, token) {
        return new Lexer.SyntaxError(message, token.position.source, token.position.index);
    }
    
    // The following tuns turns the next tokens into a single Operation tree.
    // It stops when the passed `done` condition is true
    parseExpression (tokens, done) {
        
        // If the `done` condition is immediately true, than the expression
        // is empty and the `void` operation is returned.
        if (done()) {
            const lastToken = tokens.get() || tokens.last || tokens.tail;
            tokens.inc(); return this.createOperation(this.options.voidHandler, [], lastToken.position);
        }
        
        // First generates an `expression` list [operand, operator, operand, operator, ...].
        // Then sorts the operators by precedence and returns a function.
        
        // Initialize the shunting-yard object
        const shuntingYard = new ShuntingYard();
        shuntingYard.pushOperand( this.parseOperand(tokens) );
        
        // Iterate over all the other operators and operands and add them
        // to the `expression` list until the `done` condition is matched.
        while (!done()) {
            
            // parse nexe operand
            if (tokens.get() && tokens.get().matchBinaryOperator()) {
                shuntingYard.pushOperator(
                        new Operator(this.options.binaryOperations[tokens.get().value], tokens.get().position) );
                tokens.inc(); 
                if (done()) {
                    throw this.createSyntaxError('Operand expected', tokens.get() || tokens.tail);
                }
            }
            else {
                // if the next token is not an operator, then an empty operator
                // is assumed. This means that the expression consists of 
                // two operands next to each other, without any interposed
                // operator.
                shuntingYard.pushOperator(
                        new Operator(this.options.binaryOperations[""], tokens.get(-1).position) );
            }
            
            // parse nexe operator
            shuntingYard.pushOperand( this.parseOperand(tokens) );
        }
        
        tokens.inc();
        shuntingYard.done();
        
        // Returns the root operation
        return this.popNode(shuntingYard);
    }
    
    popNode (shuntingYard) {
        if (shuntingYard.top instanceof Operator) {
            const operator = shuntingYard.pop();
            const rightHandOperand = this.popNode(shuntingYard);
            const leftHandOperand = this.popNode(shuntingYard);
            return this.createOperation(operator.handler, [leftHandOperand, rightHandOperand], operator.position);
        } else {
            return shuntingYard.pop();
        }
    }
    
    // Returns the next operand in line.
    // An operand can be a value (leaf) or an branch of the operation tree.
    parseOperand (tokens) {
        var unaryOperator, operand, token = tokens.get();
        
        // If the end of the expression has been reached, throws an error
        if (!token) {
            throw this.createSyntaxError('Operand expected', tokens.tail);
        }
        
        // If the operand is preceded by a unary operator
        if (token.matchUnaryOperator()) {
            unaryOperator = token; 
            token = tokens.inc().get();
        }
        
        // If just a number literal
        if (token.matchNumberLiteral()) {
            operand = this.createOperation(this.options.numberHandler, [token.value], token.position); 
            tokens.inc();
        }
        
        // If a string literal
        else if (token.matchStringLiteral()) {
            if (token.quoteSymbol === `'`) operand = this.createOperation(this.options.stringHandler1, [token.value], token.position);
            else if (token.quoteSymbol === `"`) operand = this.createOperation(this.options.stringHandler2, [token.value], token.position);
            else if (token.quoteSymbol === '`') operand = this.createOperation(this.options.stringHandler3, [token.value], token.position);
            tokens.inc();
        }
        
        // If an identifier
        else if (token.matchIdentifier()) {
            operand = this.createOperation(this.options.nameHandler, [token.value], token.position);
            tokens.inc();
        }
        
        // If a subexpression between `(` and `)`
        else if (token.matchSymbol('(')) {
            tokens.inc(); 
            operand = this.parseExpression(tokens,  () => tokens.get() && tokens.get().matchSymbol(")") );
        }
        
        // If a subexpression between `[` and `]`
        else if (token.matchSymbol('[')) {
            const position = token.position; 
            tokens.inc();
            let expression = this.parseExpression(tokens,  () => tokens.get() && tokens.get().matchSymbol("]") );
            operand = this.createOperation(this.options.squareGroupHandler, [expression], position);
        }
        
        // If a subexpression between `{` and `}`
        else if (token.matchSymbol('{')) {
            const position = token.position; 
            tokens.inc();
            let expression = this.parseExpression(tokens,  () => tokens.get() && tokens.get().matchSymbol("}") );
            operand = this.createOperation(this.options.curlyGroupHandler, [expression], position);
        }
        
        // No valid operand found
        else {
            throw this.createSyntaxError('Operand expected', token);
        }
        
        if (unaryOperator) {
            const handler = this.options.unaryOperations[unaryOperator.value];
            return this.createOperation(handler, [operand], unaryOperator.position);
        } else {
            return operand;
        }
    }    
    
    
    parse (source) {
        try {
            // Perform the lexical analysis
            var tokens = this.tokenize(source);    // array of tokens
            tokens.tail = {position: new Lexer.Position(source, source.length)};
            
            // Parse the entier expression and return the `evaluate` function
            return this.parseExpression(tokens, () => tokens.done() );
            
        } catch (error) {
            return async context => await context[this.options.errorHandler](error);
        }        
    }
    
    static get Position () {
        return Lexer.Position;
    }
}



class Tokens {
    
    constructor (...tokens) {
        this.tokens = tokens;
        this.index = 0;
    }
    
    inc (step=1) {
        this.index += step;
        return this;
    }
    
    get (step=0) {
        return this.tokens[this.index+step];
    }
    
    get last () {
        return this.tokens[this.tokens.length-1];
    }
    
    done () {
        return this.index >= this.tokens.length;
    }
}


class ShuntingYard {
    
    constructor (Node, Leaf) {
        this.output = [];       // output queue
        this.operators = [];    // operators stack
        this.Node = Node;       // AST node constructor
        this.Leaf = Leaf;       // AST leaf constructor
    }
    
    pushOperand (operand) {
        this.output.push(operand);
    }
    
    pushOperator (operator) {
        while (this.operators.length > 0 && this.lastOperator.preceeds(operator)) {
            this.output.push(this.operators.pop());
        }
        this.operators.push(operator);
    }
    
    done () {
        while (this.operators.length > 0) {
            this.output.push(this.operators.pop());            
        }
    }
    
    get lastOperator () {
        return this.operators[this.operators.length-1] || null;
    }
    
    get top () {
        return this.output[this.output.length-1];
    }
    
    pop () {
        return this.output.pop();
    }
}

class Operator {
    
    constructor (options, position) {
        this.options = options;
        this.position = position;
    }
    
    get precedence () { return this.options.precedence }
    
    get handler () { return this.options.handler }
    
    get isRightAssociative () { return Boolean(this.options.right) }
    
    get isLeftAssociative () { return !this.isRightAssociative }
    
    preceeds (other) {
        return this.precedence > other.precedence ||
                (this.precedence === other.precedence && other.isLeftAssociative);
    }
}



module.exports = Parser;
